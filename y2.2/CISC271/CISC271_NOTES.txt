CISC271 linear data analysis NOTES
==================================
FONT must be MONOSPACE
look into doing this: [https://castel.dev/post/lecture-notes-1/]


######
WEEK 1
######


W1 mon
======
make sure to check the Materials Widget on OnQ homepage

there is also a website that has all the course material:
https://research.cs.queensu.ca/home/cisc271/lectures.html

Assignments should be given back the following monday

Quizzes are based on Matlab and you will be using or modifying your existing code from the-
preceeding Assignment in real-time

make sure to look at the 'report guide for students' in week 1 on OnQ
also, dont submit a .zip file for the Assignments


W1 tue
======
this is a MATLAB TUTORIAL [see Documents/MATLAB/inClass_scripts/tue_C2 for the code]

the workspace contains the working variables
the command window is self explanatory
the editor contains the script editor where the main code is
use 'clc' to clear the Command Window and use 'clear' to clear the Workspace

matlab uses 1 based indexing (everything starts couting from 1 by default)

#INTRODUCE SCALAR VALUE
if you intorduce the scalar variable 'a' in the Editor and run the script a will show up in the Workspace
you can also declare scalar variables using operations (ie. sum = 5 + 5;)

if you then type 'a' into the Command Window it will print the value assigned to a in the script
additionally, if you dont put a semicolon ';' at the end of the 'a' declaration, it will print out when you run the script
	semicolons are only needed if you dont wanna print a variable or operation (like when the result is HUGE)
furthermore, disp(a) displays 'a' in a nicer, more readable way

#INTRODUCE VECTOR VALUE
you can declare a vector (row or column):
	row = [1,2,3,4];
	col = [1;2;3;4];
semicolons seperate rows in a matrix, commas seperate columns

#VECTOR OPERATIONS
you can add vectors like so:
	new_vec = [1,2,3,4] + [1,2,1,1];
to add properly the vecotrs MUST have the same dimensions

#TRANSPOSE VECTOR
either use VECTOR' or transpose(VECTOR)

#MATRICIES
make a matrix by seperating columns by spaces and rows by semicolons ';'
	mat = [1 2 3; 4 5 6; 7 8 9]

to access a matrix it is similar to slicing in Python
	mat(2,2) == [5]     (row 2, col 2)
	mat(1,:) == [1,2,3] (':' means the whole row)
	mat(:,2) == [2;5;8] (':' means the whole col)
	mat(1,1:3)= [1,2,3] (row 1, column 1 to 3)
      mat(2,1:end)= [4,5,6] (row 2, column 1 to end)
      mat(1,[1,3])= [1,3]   (row 1, column 1 & 3)

how to multiply a Matrix by a vector
	mat_mul      == mat  * [2;3;2];	retunrs a vector, normal matrix multiplication
	mat_elem_mul == mat .* 3;	returns a matrix where each element has been multiplied by a scalar value (3) 

#IF STATEMENTS
thyere basically just like from python accept without the ':'s

var = 1;
if var == 1
	disp("hello")
elseif var == 3
	disp("hola")
else	
	disp("bye")
end

#SWITCH STATEMENT
similar to the switch statement in C (although im sure its in other languages too)

m = "feb";
switch m
	case "feb"
		disp("happy febuary")
	case "jan"
		disp("happy january")
end

#FOR LOOPS
similar to Python again but without brackets (mom just have me an icy square :) )
this loop has a start of 1, a stop of 10, and a step of 2

for idx = 1:10:2
	disp(idx)
end

the following loop iterates through a list

list = [1 2 3 4]
for list_val = list
	disp(list_val)
end 

#WHILE LOOPS
very basic loops

found = false;
target = 5;
i = 1;
while found == false
	if list(i) == target
		found = true
		disp("Found")
	end
	i = i + 1

	if i == 5 %the len of list is 5
		disp("not Found")
		break %stops loop
	end
end

note that the 'list' referenced in this and previous examples is actually a 'row vector' in matlab

#PLOTTING FIGURES & GRAPHS
the function 'linspace(a,b,n)' will generate 'n' values from 'a' to 'b' numerically

now we can plot values generated from linspace using plot & figure declarations:

x = linspace(1,20,21);
y = linspace(1,40,21);
figure;
	plot(x,y,"r*")
	xlabel("x-axis")
	ylabel("y-axis")
	title("Plot :)")
	legend()

you can save plots by going into the file menu in the plot and save as

#FUNCTIONS
you can create and use functions just like most other programming languages
they are in the format of
	function "return variable" = "function name"(values)
thus:

function [addition, temp] = sum(a, b)
	addition = a+b;
	temp = 1;
end
%we can call it like so
[add, tmp] = sum(2,3)
disp(add)


1a-intro
========
using vectors and matricies, hence linear
using data, real and fake
thus, we're analyzing this linear data

we will be using matlab for parts of this course

some basic lin.alg examples:
Eigen Vector
	is the matrix such that:
	Av = {LAMBDA}v

Hilbert Matrix
	is a matrix where each element is:
	a = 1/[i+j-1]
	where i and j are a's indexes


1b-class logistics
==================
see {mon W1}


1c-vectors withim matricies
===========================
alsways use: What Would Einstein Do? (WWED)

also, VECTORS are denoted by V, for example: [Vx] is the VECTOR x

consider: 2x2 matrix:

	A[in]R^[2x2]

and a vector with 2 entries:

	Vc[in]R^2, Vw[in]R^2
thus:
	Vc = A*Vw
  [c1;c2] = [a11, a12; a21, a22] * [w1; w2]
	  = [a11*w1 + a12*w2; a21*w1 + a22*w2]
	  = w1*[a11; a21] + w2*[a12; a22]
	  = w1*Va1 + w2*Va2	where a1 and a2 are column vectors of A

for matrix multipication the columns of the first multiple (X*y) must equal the number of rows in the second multiple (x*Y)

consider that any 2 vectors with a 'weight' or multiple can equal any vector on the plane:
	Vc = w1*Va1 + w2*Va2
thus any vector c can be made from the sum of the weighted vectors a1 and a2

this can also be extended to 3-space such that:

	Vc = w1*Va1 + w2*Va2 + w3*Va3
this can be extended to n-dimensions


1d-EigenFacts
=============
something thats true and should always be assumed as such (within the scope of this course)

consider:
	the vector v [Vv]
	the matrix A [A]
such that:
	A*Vv = Vu

if vector u is linear dependent to vector v it is an EigenVector: 	(linear dependence is when a set of vectors are multiples of eachother)
	A*Vv = lmda*Vv							(lmda = lambda, lmda*V is an EigenVector)

Properties of EigenValues:
for any square matrix [A] 			(A[in]R^[nxn])
EigenValues are contained in the set [L(A)]:	(where L(A) is the set of matrix A's EigenValues)

	matrix [A] has [n] eigenvalues, possibly complex, not distingct
        symmetric matrix [B] has [n] real number EigenValues
	skew-symmetric matrix [S] has [n] EigenValues, either zero or purely imaginary
	Triangular matrix [T] has all the diagonaly values in L(T) [t_ii[in]L(T)] where i are the values from 0 to the largest index in the matrix
	if 2 matricies [A,C] are similar (related by an inveratable matrix), then [L(A)=L(C)]
		because trace and determinant are derived from EigenValues, these also hold for similar Matricies:
		[tr(A)==tr(C) && |A|==|C|]


2a-intro to graphs
==================
Graphs are composed of corners (verticies) and edges [G(V,E)]
an adjacentcy matrix for a graph [G] is [A(G)], which is symmetric and binary	(binary, elements are either [0,1])

how can we represent a graph as a matrix?
	A graph is a mathematical structure of:

	Set [vT] of vertecies. NONEMPTY and FINITE, elements are [v_j]
	Set [E]  of edges. no repetitions or ordering: [e_k = {v_i*v_q} or = (v_i*v_q)=(v_q*v_i)]

	the graph [G] is represented as [G(vT, E)]
		G = {{1 2 3 4 5},(23),(12), (45)}	(edge from 2-3, 1-2, 4-5)


2b-definitions for graphs
=========================
consider:
	G# = {{1 2 3 4 5},(12),(23),(24),(45),(46)}

	(1)--(2)--(4)--(6)
	    /	     \
	  (3)	     (5)

definitions:
	incident	a vertex and edge are incadent if theyre adjacent (connected)
			an edge is incadent to another edge if they share a vertex	
			a vertex is incadent to another vertex if they share an edge

	degree		the degree of a vertex is the number of edges incadent (connected) to is

	subgraph (sG)	a graph [G] is a subgraph if and only if it is contained within another graph [H] such that:
				[vT_G[IN]vT_H] [AND] [E_G[IN]E_H]

	bipartite	a graph [G(vT, E)] is bipartite if [vT] can be partitioned into 2 sets [vT_L, vT_R] such that:
			each edge can be written as [e = (v_i, v_j)] where
				[v_i[IN]vT_L] [AND] [v_j[IN]vT_R]

			if you were to pick the graph up from one of its vertecies, it would make / be a tree. 
			[G#] is an example of a bipartite graph

	path		a finite sequence of incadent edges from [v_i->v_j]

	component sG	a subgraph created from cutting an edge that results in a subgraph that has no other paths to the rest 
			of the graph barring the edge that was cut.
			we could take [G#] as an example:

				(1)--(2)--(4)--(6)
				    /	     \
			 	  (3)	     (5)

			if we then cut (24):

				(1)--(2)   (4)--(6)
				    /	     \
				  (3)	     (5)

			we get 2 component subgraphs:
				G1 = {{1 2 3},(12),(23)}
				G2 = {{4 5 6},(45),(46)}

			in other words, there should be a path to any part in a component subgraph from any other vT of-
			the component subgraph
			additionally,   there should be NO path from a part of the component subgraph to any part not-
			within the component subgraph

NOT allowed:
	multiple edge	2 distingct edges [p,q] that both start from the same vertex and both end at the same vertex
			e_p = e_q

	loop		an edge that starts and ends at the same vertex
			e = (v_i, v_i)
	
	pseudographs	set of vertecies and edges that has atleast one multiple edge and/or loop 

				
2c-Adjacency Matrix
===================
let [G(vT,E)] have n Vertecies, m Edges
Adjacecy Matrix:
	[A(G)] is defined as a matrix with [m x m] dimensions such that:

		/ 1 if (v_i,v_j)  [IN] E 
	 a_ij ==
		\ 0 if (v_i,v_j) ~[IN] E						('~' means NOT)

	thus [A] is binary and, because [(v1v2)=(v2v1)], A is also symmetric.
	[A] is always real and always has a 0-diagonal.
	[A] always has only real EigenValues

consider:
	G1 = (1)---(2) (4)
	       \   /     \
	        (3)      (5)

	A(G1) = 			each row corresponds to a vertex, the values in the row correspond to each vertex 
	(1)	/0 1 1 0 0\		in the graph, 1 if the row-vT and value-vT are incident. 0 otherwise
	(2)	|1 0 1 0 0|
	(3)	|1 1 0 0 0|
	(4)	|0 0 0 0 1|
	(5)	\0 0 0 1 0/
	
	G# = (1)--(2)--(4)--(6)
	          /      \
	        (3)	 (5)

	A(G#) = 
		/0 1 0 0 0 0\
		|1 0 1 1 0 0|
		|0 1 0 0 0 0|
		|0 1 0 0 1 1|
		|0 0 0 1 0 0|
		\0 0 0 1 0 0/

ones vector:
	is defined as a vector where each entry is 1
		V1 = {1;1;...;1}
	it can count the number of 1's in a binary matrix

degree vector:
if you multiply an Adjacency marix [A(G)] by the ones vector, the product will be the degree vector of [G]

	A(G1)*V1 = [2;2;2;1;1]
	A(G#)*V1 = 
		   /0 1 0 0 0 0\   /1\
		   |1 0 1 1 0 0|   |1|
		   |0 1 0 0 0 0| * |1|
		   |0 1 0 0 1 1|   |1|
		   |0 0 0 1 0 0|   |1|
		   \0 0 0 1 0 0/   \1/

		 = [1;3;1;3;1;1]
thus this is the degree vector for [G#]


2d-non bipartite braphs
=======================
consider:
	G3 = (1)-(2)  (4) (5)
	       \ /	\ /
     	       (3)	(6)
	
	there are 2 component subgraphs [sL,sR] within this graph
	while sR may be bipartite, sL and thus G3 is not

	A(G3) = 
		/0 1 1 0 0 0\
		|1 0 1 0 0 0|
		|1 1 0 0 0 0|
		|0 0 0 0 1 0|
		|0 0 0 1 0 1|
		\0 0 0 0 1 0/

	we can see the 2 discrete components of the graph within the matric by the groups of 1's

consider:
	G4 = 
	     (1)-(2)-(4)-(5)
	       \ /     \ /
     	       (3)     (6)

	A(G4) = 
		/0 1 1 0 0 0\
		|1 0 1 1 0 0|
		|1 1 0 0 0 0|
		|0 1 0 0 1 0|
		|0 0 0 1 0 1|
		\0 0 0 0 1 0/

2-learning summary
------------------
we should now be able to:
	characterize a graph
	make an Adjacency matrix from a specification or diagram
	draw a graph from an Adjacency matrix
	
	try:
		coding an edge list to adjacency matrix


3a-degree matrix
================
recall the degree of a vertex is the number of edges the vertex is connected to
the degree vector is the product of [A(G)*V1 = dV]

we can use [dV] to construct the degree matrix:
	D(G) = diag(dV) =

		/d1 0   0 ...  0\
		|0  d2  0 ...  0|
		|...............|
		\0  0   0 ... dn/

the diagonal is made up of the entries from the degree vector [dV]
by construction this matrix is positive, semidefinite, and symmetric


3b-Laplacian matrix
===================
comes from the Adjacency & Degree matrix and describes both

laplacian matrix:
	L(G) = D(G)-A(G)	(D has 0-values accept for on diagonal, A has 0-values only on diagonal)
	by construction, L is symmetric

steps of algorithim for solving (by hand):
{1}	write [A(G)]
{2}	negate (multiply by -1) all non-zero entries
{3}	replace diagonal entries [a_ii] with [d_i [IN]dV]

consider:
	G# = (1)--(2)--(4)--(6)
	          /      \
	        (3)	 (5)	
step {1}
	L1 =
		/  1 0 0 0 0\
		|1   1 1 0 0|
		|0 1   0 0 0|
		|0 1 0   1 1|
		|0 0 0 1   0|
		\0 0 0 1 0  /
step {2}
	L1 =
		/   -1  0  0  0  0\
		|-1    -1 -1  0  0|
		| 0 -1     0  0  0|
		| 0 -1  0    -1 -1|
		| 0  0  0 -1     0|
		\ 0  0  0 -1  0   /
step{3}
	L1 =
		/ 1 -1  0  0  0  0\
		|-1  3 -1 -1  0  0|
		| 0 -1  1  0  0  0|
		| 0 -1  0  3 -1 -1|
		| 0  0  0 -1  1  0|
		\ 0  0  0 -1  0  1/
thus, we have found the laplacian matrix of [G#]

consider:
	G1 =    (1)-(2) (4)
	          \ /     \
	          (3)     (5)

	L1 = 
		/ 2 -1 -1  0  0\
		|-1  2 -1  0  0|     / L_b1    0 \
		|-1 -1  2  0  0| ==  |           |	(where [L_b] is a block in the L matrix)
		| 0  0  0  1 -1|     \ 0    L_b2 /
		\ 0  0  0 -1  1/

consider:
	A(G#) = 
		/0 0 0 1 1 1\
		|0 0 0 0 0 1|    / 0        A_b \
		|0 0 0 0 0 1| == |              |	(where a matrix [A^T] is transposed version of [A])
		|1 0 0 0 0 0|    \ [A_b]^T    0 /
		|1 0 0 0 0 0|    
		\1 1 1 0 0 0/

	NOTE: [G#] is a bipartite graph. every bipartite graph can be represented to have this form of Adjacency matrix

in summary:
	the Laplacian Matrix is both: symmetric & real
	
	additionally it is Diagonally Dominant (d.d), which means:
		for every row, the sum, excluding the diagonal entry, of the row must be less than or equal to the diagonal entry
		l_ii >= SUM_[j/=i](|l_ij|)			NOTE: it is the sum of the ABSOLUTE values

	the Laplacian matrix (and any d.d matrix) is Positive Semidefinite:
		where every EigenValue is non-negativem [EigenValues >= 0] 

	observe:
		L*V1 = (D-A)*V1 = dV-dV = V0
	thus:
		V1 is an EigenVector &
		0 is its EigenValue


3c-Laplacian EigenValues
========================
getting EigenValues from L:

	G1 =    (1)---(2) (4)
	          \   /     \
	           (3)      (5)

	L1 = 
		/ 2 -1 -1  0  0\
		|-1  2 -1  0  0|     / L_b1    0 \
		|-1 -1  2  0  0| ==  |           |	(where [L_b] is a diagonal block in the L matrix)
		| 0  0  0  1 -1|     \ 0    L_b2 /
		\ 0  0  0 -1  1/

using MATLAB we can find the EigenValues [Ev] of L1:

	Ev1 = 0
	Ev2 = 0
	Ev3 = 2
	Ev4 = 3
	Ev5 = 3
from these Eigen Values we can derive:
	
	dimension of nullspace of L1	= 2	(2 eigenvalues are 0)
	dimension of Eigenspace:
			 Ev3		= 1	(1 eigenvalue is 2 [Ev3=2])
			 Ev4,5		= 2	(2 eigenvalues are 3)

observing EigenVectors:
	positive and negative values in an EigenVector derived from [L(G)] correspont to visual clusters in [G]

	the positive entries are those that are in the same cluster as the vertex that we derived-
	the EigenVector we are using

	
3d-Laplacian matrix: Feilder vector
===================================
used to find the binary clustering of vertices

steps for algorithim to find Feilder vector:
{1}	create [L(G)] of graph [G]
{2}	compute the second EigenVector [Ev2] of [L(G)]
{3}	assign the negative entries of [Ev2] to a Set 1
{4}	assign the positive entries of [Ev2] to a Set 2

Laplacian matrix properties:

	Feilder vector is a binary clustering of verticies, derived from the EigenVectors of L
	symmetric, postitive semidefinite
	ones vector [V1] is the EigenVector of 0-EigenValue
	dimensions of nullspace is equal to the number of graph components
	for [k] components:
		it is similar to a matrix with k diagonal blocks (see {3c} for example)

3-learning summary
------------------
we should now be able to:
	find the degree of a vertex in a graph
	create Laplacian matrix [L(G)]
	compute the # of graph components
	compute a binary clustering of vertecies
	
	try:
		program to find clusters from Adjacency matrix [A(G)]


######
WEEK 2
######